
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/overlap_regridder.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_overlap_regridder.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_overlap_regridder.py:


OverlapRegridder
================

The overlap regridder works in two stages. First, it searches the source grid
for all faces of the target grid, computes the intersections, and stores all
overlaps between source and target faces. This occurs when the regridder is
initialized. Second, the regridder applies the weights: it reduces the
collection of overlapping faces to a single value for the target face.

There are many reductions possible. The best choice generally differs based on
the physical meaning of the variable, or the application. Xugrid provides a
number of reductions, but it's also possible to use a custom reduction
function. This is demonstrated here.

We start with the same example as in the quick overview.

.. GENERATED FROM PYTHON SOURCE LINES 19-25

.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np

    import xugrid as xu








.. GENERATED FROM PYTHON SOURCE LINES 26-28

We'll use a part of a triangular grid with the surface elevation (including
some bathymetry) of the Netherlands, and a coarser target grid.

.. GENERATED FROM PYTHON SOURCE LINES 28-52

.. code-block:: default



    def create_grid(bounds, nx, ny):
        """
        Create a simple grid of triangles covering a rectangle.
        """
        import numpy as np
        from matplotlib.tri import Triangulation

        xmin, ymin, xmax, ymax = bounds
        dx = (xmax - xmin) / nx
        dy = (ymax - ymin) / ny
        x = np.arange(xmin, xmax + dx, dx)
        y = np.arange(ymin, ymax + dy, dy)
        y, x = [a.ravel() for a in np.meshgrid(y, x, indexing="ij")]
        faces = Triangulation(x, y).triangles
        return xu.Ugrid2d(x, y, -1, faces)


    uda = xu.data.elevation_nl().ugrid.sel(
        x=slice(125_000, 225_000), y=slice(440_000, 500_000)
    )
    grid = create_grid(uda.ugrid.total_bounds, nx=7, ny=6)








.. GENERATED FROM PYTHON SOURCE LINES 53-58

.. code-block:: default


    fig, ax = plt.subplots()
    uda.ugrid.plot(vmin=-20, vmax=90, cmap="terrain", ax=ax)
    grid.plot(ax=ax, color="red")




.. image-sg:: /examples/images/sphx_glr_overlap_regridder_001.png
   :alt: overlap regridder
   :srcset: /examples/images/sphx_glr_overlap_regridder_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.LineCollection object at 0x7f9267a81c70>



.. GENERATED FROM PYTHON SOURCE LINES 59-69

Method comparison
-----------------

Let's compare the different reduction functions that are available in
xugrid. We'll create a regridder once for every method, and plot the results
side by side.

..note::
  Sum and conductance (which is first-order conservative) result in much higher
  values. The white in the figures are high values, not no data.

.. GENERATED FROM PYTHON SOURCE LINES 69-92

.. code-block:: default


    functions = [
        "mean",
        "harmonic_mean",
        "geometric_mean",
        "sum",
        "minimum",
        "maximum",
        "mode",
        "median",
        "conductance",
        "max_overlap",
    ]

    fig, axes = plt.subplots(nrows=5, ncols=2, figsize=(10, 25), sharey=True, sharex=True)
    axes = axes.ravel()

    for f, ax in zip(functions, axes):
        regridder = xu.OverlapRegridder(source=uda, target=grid, method=f)
        result = regridder.regrid(uda)
        result.ugrid.plot(vmin=-20, vmax=90, cmap="terrain", ax=ax)
        ax.set_title(f)




.. image-sg:: /examples/images/sphx_glr_overlap_regridder_002.png
   :alt: mean, harmonic_mean, geometric_mean, sum, minimum, maximum, mode, median, conductance, max_overlap
   :srcset: /examples/images/sphx_glr_overlap_regridder_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 93-110

Custom reductions
-----------------

It's also possible to define your own reduction methods. Such a method is
inserted during the ``.regrid`` call and compiled by `Numba`_ for performance.

A valid reduction method must be compileable by Numba, and takes exactly three
arguments: ``values``, ``indices``, ``weights``.

* ``values``: is the ravelled array containing the (float) source values.
* ``indices``: contains the flat, or "linear", (integer) indices into the
  source values for a single target face.
* ``weights``: contains the (float) overlap between the target face and the
  source faces. The size of ``weights`` is equal to the size of ``indices``.

Xugrid regridder reduction functions are implemented in such a way. For a example, the area
could be implemented as follows:

.. GENERATED FROM PYTHON SOURCE LINES 110-117

.. code-block:: default



    def mean(values, indices, weights):
        subset = values[indices]
        return np.nansum(subset * weights) / np.nansum(weights)









.. GENERATED FROM PYTHON SOURCE LINES 118-128

.. note::
   * Custom reductions methods must be able to deal with NaN values as these
     are commonly encountered in datasets as a "no data value".
   * If Python features are used that are unsupported by Numba, you will get
     somewhat obscure errors. In such a case, test your function with
     synthetic values for ``values, indices, weights``.
   * The built-in mean is more efficient, avoiding temporary memory
     allocations.

To use our custom method, we provide at initialization of the OverlapRegridder:

.. GENERATED FROM PYTHON SOURCE LINES 128-133

.. code-block:: default


    regridder = xu.OverlapRegridder(uda, grid, method=mean)
    result = regridder.regrid(uda)
    result.ugrid.plot(vmin=-20, vmax=90, cmap="terrain")




.. image-sg:: /examples/images/sphx_glr_overlap_regridder_003.png
   :alt: overlap regridder
   :srcset: /examples/images/sphx_glr_overlap_regridder_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.PolyCollection object at 0x7f92723c0310>



.. GENERATED FROM PYTHON SOURCE LINES 134-138

Not every reduction uses the weights argument. For example, computing an
arbitrary quantile value requires just the values. Again, make sure the
function can deal with NaN values! -- hence ``nanpercentile`` rather than
``percentile`` here.

.. GENERATED FROM PYTHON SOURCE LINES 138-149

.. code-block:: default



    def p17(values, indices, weights):
        subset = values[indices]
        return np.nanpercentile(subset, 17)


    regridder = xu.OverlapRegridder(uda, grid, method=p17)
    result = regridder.regrid(uda)
    result.ugrid.plot(vmin=-20, vmax=90, cmap="terrain")




.. image-sg:: /examples/images/sphx_glr_overlap_regridder_004.png
   :alt: overlap regridder
   :srcset: /examples/images/sphx_glr_overlap_regridder_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.PolyCollection object at 0x7f927238a040>



.. GENERATED FROM PYTHON SOURCE LINES 150-151

.. _Numba: https://numba.pydata.org/


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  4.848 seconds)


.. _sphx_glr_download_examples_overlap_regridder.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: overlap_regridder.py <overlap_regridder.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: overlap_regridder.ipynb <overlap_regridder.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
