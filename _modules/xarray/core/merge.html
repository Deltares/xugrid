
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>xarray.core.merge &#8212; Xugrid 0.6.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/theme-deltares.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/xarray/core/merge';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/xugrid-logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../_static/xugrid-logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
    <p class="title logo__title">Xugrid</p>
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../dev_docs.html">
                        Development
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/xugrid" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg" class="icon-link-image" alt="GitHub"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.nl/en/" title="Deltares" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../_static/deltares-white.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../dev_docs.html">
                        Development
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/xugrid" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg" class="icon-link-image" alt="GitHub"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.nl/en/" title="Deltares" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../_static/deltares-white.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">xarray.core.merge</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for xarray.core.merge</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">xarray.core</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">xarray.core.alignment</span> <span class="kn">import</span> <span class="n">deep_align</span>
<span class="kn">from</span> <span class="nn">xarray.core.duck_array_ops</span> <span class="kn">import</span> <span class="n">lazy_array_equiv</span>
<span class="kn">from</span> <span class="nn">xarray.core.indexes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">Indexes</span><span class="p">,</span>
    <span class="n">create_default_index_implicit</span><span class="p">,</span>
    <span class="n">filter_indexes_from_coords</span><span class="p">,</span>
    <span class="n">indexes_equal</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xarray.core.utils</span> <span class="kn">import</span> <span class="n">Frozen</span><span class="p">,</span> <span class="n">compat_dict_union</span><span class="p">,</span> <span class="n">dict_equiv</span><span class="p">,</span> <span class="n">equivalent</span>
<span class="kn">from</span> <span class="nn">xarray.core.variable</span> <span class="kn">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">as_variable</span><span class="p">,</span> <span class="n">calculate_dimensions</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">xarray.core.coordinates</span> <span class="kn">import</span> <span class="n">Coordinates</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>
    <span class="kn">from</span> <span class="nn">xarray.core.types</span> <span class="kn">import</span> <span class="n">CombineAttrsOptions</span><span class="p">,</span> <span class="n">CompatOptions</span><span class="p">,</span> <span class="n">JoinOptions</span>

    <span class="n">DimsLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span>
    <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Any</span>
    <span class="n">VariableLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">DimsLike</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">DimsLike</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">],</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">DimsLike</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="n">XarrayValue</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">VariableLike</span><span class="p">]</span>
    <span class="n">DatasetLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">XarrayValue</span><span class="p">]]</span>
    <span class="n">CoercibleValue</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">XarrayValue</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
    <span class="n">CoercibleMapping</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">]]</span>


<span class="n">PANDAS_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>

<span class="n">_VALID_COMPAT</span> <span class="o">=</span> <span class="n">Frozen</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;identical&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;equals&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;minimal&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;no_conflicts&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;override&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">Context</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;object carrying the information of a call&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">broadcast_dimension_size</span><span class="p">(</span><span class="n">variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract dimension sizes from a dictionary of variables.</span>

<span class="sd">    Raises ValueError if any dimensions have different sizes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> not aligned&quot;</span><span class="p">)</span>
            <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">return</span> <span class="n">dims</span>


<span class="k">class</span> <span class="nc">MergeError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Error class for merge failures due to incompatible arguments.&quot;&quot;&quot;</span>

    <span class="c1"># inherits from ValueError for backward compatibility</span>
    <span class="c1"># TODO: move this to an xarray.exceptions module?</span>


<span class="k">def</span> <span class="nf">unique_variable</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">,</span>
    <span class="n">equals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the unique variable from a list of variables or raise MergeError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : hashable</span>
<span class="sd">        Name for this variable.</span>
<span class="sd">    variables : list of Variable</span>
<span class="sd">        List of Variable objects, all of which go by the same name in different</span>
<span class="sd">        inputs.</span>
<span class="sd">    compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, &quot;no_conflicts&quot;, &quot;override&quot;}, optional</span>
<span class="sd">        Type of equality check to use.</span>
<span class="sd">    equals : None or bool, optional</span>
<span class="sd">        corresponding to result of compat test</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Variable to use in the result.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    MergeError: if any of the variables are not equal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">compat</span> <span class="o">==</span> <span class="s2">&quot;override&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">combine_method</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">compat</span> <span class="o">==</span> <span class="s2">&quot;minimal&quot;</span><span class="p">:</span>
        <span class="n">compat</span> <span class="o">=</span> <span class="s2">&quot;broadcast_equals&quot;</span>

    <span class="k">if</span> <span class="n">compat</span> <span class="o">==</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">:</span>
        <span class="n">dim_lengths</span> <span class="o">=</span> <span class="n">broadcast_dimension_size</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">dim_lengths</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compat</span> <span class="o">==</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">:</span>
        <span class="n">combine_method</span> <span class="o">=</span> <span class="s2">&quot;fillna&quot;</span>

    <span class="k">if</span> <span class="n">equals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># first check without comparing values i.e. no computes</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">equals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">compat</span><span class="p">)(</span><span class="n">var</span><span class="p">,</span> <span class="n">equiv</span><span class="o">=</span><span class="n">lazy_array_equiv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">equals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">equals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># now compare values with minimum number of computes</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">equals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">compat</span><span class="p">)(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">equals</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">equals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;conflicting values for variable </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> on objects to be combined. &quot;</span>
            <span class="s2">&quot;You can skip this check by specifying compat=&#39;override&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">combine_method</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">combine_method</span><span class="p">)(</span><span class="n">var</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_assert_compat_valid</span><span class="p">(</span><span class="n">compat</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">compat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_VALID_COMPAT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compat=</span><span class="si">{</span><span class="n">compat</span><span class="si">!r}</span><span class="s2"> invalid: must be </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">_VALID_COMPAT</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">MergeElement</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Index</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_assert_prioritized_valid</span><span class="p">(</span>
    <span class="n">grouped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]],</span>
    <span class="n">prioritized</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">MergeElement</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make sure that elements given in prioritized will not corrupt any</span>
<span class="sd">    index given in grouped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prioritized_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">prioritized</span><span class="p">)</span>
    <span class="n">grouped_by_index</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">elements_list</span> <span class="ow">in</span> <span class="n">grouped</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">elements_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grouped_by_index</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">indexes</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index</span>

    <span class="c1"># An index may be corrupted when the set of its corresponding coordinate name(s)</span>
    <span class="c1"># partially overlaps the set of names given in prioritized</span>
    <span class="k">for</span> <span class="n">index_id</span><span class="p">,</span> <span class="n">index_coord_names</span> <span class="ow">in</span> <span class="n">grouped_by_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">index_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">index_coord_names</span><span class="p">)</span>
        <span class="n">common_names</span> <span class="o">=</span> <span class="n">index_names</span> <span class="o">&amp;</span> <span class="n">prioritized_names</span>
        <span class="k">if</span> <span class="n">common_names</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_names</span><span class="p">):</span>
            <span class="n">common_names_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">common_names</span><span class="p">)</span>
            <span class="n">index_names_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index_coord_names</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot set or update variable(s) </span><span class="si">{</span><span class="n">common_names_str</span><span class="si">}</span><span class="s2">, which would corrupt &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;the following index built from coordinates </span><span class="si">{</span><span class="n">index_names_str</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indexes</span><span class="p">[</span><span class="n">index_id</span><span class="p">]</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">merge_collected</span><span class="p">(</span>
    <span class="n">grouped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]],</span>
    <span class="n">prioritized</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">MergeElement</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;minimal&quot;</span><span class="p">,</span>
    <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
    <span class="n">equals</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge dicts of variables, while resolving conflicts appropriately.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grouped : mapping</span>
<span class="sd">    prioritized : mapping</span>
<span class="sd">    compat : str</span>
<span class="sd">        Type of equality check to use when checking for conflicts.</span>
<span class="sd">    combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                    &quot;override&quot;} or callable, default: &quot;override&quot;</span>
<span class="sd">        A callable or a string indicating how to combine attrs of the objects being</span>
<span class="sd">        merged:</span>

<span class="sd">        - &quot;drop&quot;: empty attrs on returned Dataset.</span>
<span class="sd">        - &quot;identical&quot;: all attrs must be the same on every object.</span>
<span class="sd">        - &quot;no_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name must also have the same value.</span>
<span class="sd">        - &quot;drop_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name but different values are dropped.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and copy attrs from the first dataset to</span>
<span class="sd">          the result.</span>

<span class="sd">        If a callable, it must expect a sequence of ``attrs`` dicts and a context object</span>
<span class="sd">        as its only parameters.</span>
<span class="sd">    equals : mapping, optional</span>
<span class="sd">        corresponding to result of compat test</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict with keys taken by the union of keys on list_of_mappings,</span>
<span class="sd">    and Variable values corresponding to those that should be found on the</span>
<span class="sd">    merged result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prioritized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prioritized</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">equals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">equals</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_assert_compat_valid</span><span class="p">(</span><span class="n">compat</span><span class="p">)</span>
    <span class="n">_assert_prioritized_valid</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">prioritized</span><span class="p">)</span>

    <span class="n">merged_vars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">merged_indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">index_cmp_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">elements_list</span> <span class="ow">in</span> <span class="n">grouped</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">prioritized</span><span class="p">:</span>
            <span class="n">variable</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">prioritized</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">merged_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">merged_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexed_elements</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">elements_list</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">indexed_elements</span><span class="p">:</span>
                <span class="c1"># TODO(shoyer): consider adjusting this logic. Are we really</span>
                <span class="c1"># OK throwing away variable without an index in favor of</span>
                <span class="c1"># indexed variables, without even checking if values match?</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">indexed_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">other_var</span><span class="p">,</span> <span class="n">other_index</span> <span class="ow">in</span> <span class="n">indexed_elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">indexes_equal</span><span class="p">(</span>
                        <span class="n">index</span><span class="p">,</span> <span class="n">other_index</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">other_var</span><span class="p">,</span> <span class="n">index_cmp_cache</span>
                    <span class="p">):</span>
                        <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;conflicting values/indexes on objects to be combined fo coordinate </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;first index: </span><span class="si">{</span><span class="n">index</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">second index: </span><span class="si">{</span><span class="n">other_index</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;first variable: </span><span class="si">{</span><span class="n">variable</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">second variable: </span><span class="si">{</span><span class="n">other_var</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="n">compat</span> <span class="o">==</span> <span class="s2">&quot;identical&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">other_variable</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indexed_elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_equiv</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">other_variable</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
                                <span class="s2">&quot;conflicting attribute values on combined &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;variable </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">first value: </span><span class="si">{</span><span class="n">variable</span><span class="o">.</span><span class="n">attrs</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">second value: </span><span class="si">{</span><span class="n">other_variable</span><span class="o">.</span><span class="n">attrs</span><span class="si">!r}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                <span class="n">merged_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="n">merged_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">merge_attrs</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">attrs</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indexed_elements</span><span class="p">],</span>
                    <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">merged_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">variable</span> <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">elements_list</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">merged_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_variable</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">compat</span><span class="p">,</span> <span class="n">equals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="n">MergeError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">compat</span> <span class="o">!=</span> <span class="s2">&quot;minimal&quot;</span><span class="p">:</span>
                        <span class="c1"># we need more than &quot;minimal&quot; compatibility (for which</span>
                        <span class="c1"># we drop conflicting coordinates)</span>
                        <span class="k">raise</span>

                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">merged_vars</span><span class="p">:</span>
                    <span class="n">merged_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">merge_attrs</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">attrs</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">],</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span>
                    <span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_vars</span><span class="p">,</span> <span class="n">merged_indexes</span>


<span class="k">def</span> <span class="nf">collect_variables_and_indexes</span><span class="p">(</span>
    <span class="n">list_of_mappings</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DatasetLike</span><span class="p">],</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect variables and indexes from list of mappings of xarray objects.</span>

<span class="sd">    Mappings must either be Dataset objects, or have values of one of the</span>
<span class="sd">    following types:</span>
<span class="sd">    - an xarray.Variable</span>
<span class="sd">    - a tuple `(dims, data[, attrs[, encoding]])` that can be converted in</span>
<span class="sd">      an xarray.Variable</span>
<span class="sd">    - or an xarray.DataArray</span>

<span class="sd">    If a mapping of indexes is given, those indexes are assigned to all variables</span>
<span class="sd">    with a matching key/name.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">grouped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">grouped</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">variable</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">append_all</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">list_of_mappings</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">append_all</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">mapping</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="n">coords_</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># use private API for speed</span>
                <span class="n">indexes_</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>
                <span class="c1"># explicitly overwritten variables should take precedence</span>
                <span class="n">coords_</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">indexes_</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">append_all</span><span class="p">(</span><span class="n">coords_</span><span class="p">,</span> <span class="n">indexes_</span><span class="p">)</span>

            <span class="n">variable</span> <span class="o">=</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                <span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">variable</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">name</span><span class="p">,):</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">create_default_index_implicit</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                <span class="n">append_all</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grouped</span>


<span class="k">def</span> <span class="nf">collect_from_coordinates</span><span class="p">(</span>
    <span class="n">list_of_coords</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Coordinates</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect variables and indexes to be merged from Coordinate objects.&quot;&quot;&quot;</span>
    <span class="n">grouped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">list_of_coords</span><span class="p">:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">variables</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">xindexes</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">grouped</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">grouped</span>


<span class="k">def</span> <span class="nf">merge_coordinates_without_align</span><span class="p">(</span>
    <span class="n">objects</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Coordinates</span><span class="p">],</span>
    <span class="n">prioritized</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">MergeElement</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_dims</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(),</span>
    <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge variables/indexes from coordinates without automatic alignments.</span>

<span class="sd">    This function is used for merging coordinate from pre-existing xarray</span>
<span class="sd">    objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="n">collect_from_coordinates</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exclude_dims</span><span class="p">:</span>
        <span class="n">filtered</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">MergeElement</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_elements</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">elements</span>
                <span class="k">if</span> <span class="n">exclude_dims</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">new_elements</span><span class="p">:</span>
                <span class="n">filtered</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_elements</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">collected</span>

    <span class="c1"># TODO: indexes should probably be filtered in collected elements</span>
    <span class="c1"># before merging them</span>
    <span class="n">merged_coords</span><span class="p">,</span> <span class="n">merged_indexes</span> <span class="o">=</span> <span class="n">merge_collected</span><span class="p">(</span>
        <span class="n">filtered</span><span class="p">,</span> <span class="n">prioritized</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span>
    <span class="p">)</span>
    <span class="n">merged_indexes</span> <span class="o">=</span> <span class="n">filter_indexes_from_coords</span><span class="p">(</span><span class="n">merged_indexes</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_coords</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">merged_coords</span><span class="p">,</span> <span class="n">merged_indexes</span>


<span class="k">def</span> <span class="nf">determine_coords</span><span class="p">(</span>
    <span class="n">list_of_mappings</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DatasetLike</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of dicts with xarray object values, identify coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_mappings : list of dict or list of Dataset</span>
<span class="sd">        Of the same form as the arguments to expand_variable_dicts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coord_names : set of variable names</span>
<span class="sd">    noncoord_names : set of variable names</span>
<span class="sd">        All variable found in the input should appear in either the set of</span>
<span class="sd">        coordinate or non-coordinate names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">noncoord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">list_of_mappings</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">noncoord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">_coords</span><span class="p">)</span>  <span class="c1"># use private API for speed</span>
                    <span class="c1"># explicitly overwritten variables should take precedence</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">noncoord_names</span>


<span class="k">def</span> <span class="nf">coerce_pandas_values</span><span class="p">(</span><span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">CoercibleMapping</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">DatasetLike</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert pandas values found in a list of labeled objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objects : list of Dataset or mapping</span>
<span class="sd">        The mappings may contain any sort of objects coercible to</span>
<span class="sd">        xarray.Variables as keys, including pandas objects.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List of Dataset or dictionary objects. Any inputs or values in the inputs</span>
<span class="sd">    that were pandas objects have been converted into native xarray objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="n">variables</span><span class="p">:</span> <span class="n">DatasetLike</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">PANDAS_TYPES</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">PANDAS_TYPES</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_get_priority_vars_and_indexes</span><span class="p">(</span>
    <span class="n">objects</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DatasetLike</span><span class="p">],</span>
    <span class="n">priority_arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;equals&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">MergeElement</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract the priority variable from a list of mappings.</span>

<span class="sd">    We need this method because in some cases the priority argument itself</span>
<span class="sd">    might have conflicting values (e.g., if it is a dict with two DataArray</span>
<span class="sd">    values with conflicting coordinate values).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objects : list of dict-like of Variable</span>
<span class="sd">        Dictionaries in which to find the priority variables.</span>
<span class="sd">    priority_arg : int or None</span>
<span class="sd">        Integer object whose variable should take priority.</span>
<span class="sd">    compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, &quot;no_conflicts&quot;, &quot;override&quot;}, optional</span>
<span class="sd">        String indicating how to compare non-concatenated variables of the same name for</span>
<span class="sd">        potential conflicts. This is passed down to merge.</span>

<span class="sd">        - &quot;broadcast_equals&quot;: all values must be equal when variables are</span>
<span class="sd">          broadcast against each other to ensure common dimensions.</span>
<span class="sd">        - &quot;equals&quot;: all values and dimensions must be the same.</span>
<span class="sd">        - &quot;identical&quot;: all values, dimensions and attributes must be the</span>
<span class="sd">          same.</span>
<span class="sd">        - &quot;no_conflicts&quot;: only values which are not null in both datasets</span>
<span class="sd">          must be equal. The returned dataset then contains the combination</span>
<span class="sd">          of all non-null values.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and pick variable from first dataset</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A dictionary of variables and associated indexes (if any) to prioritize.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">priority_arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="n">collected</span> <span class="o">=</span> <span class="n">collect_variables_and_indexes</span><span class="p">([</span><span class="n">objects</span><span class="p">[</span><span class="n">priority_arg</span><span class="p">]])</span>
    <span class="n">variables</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">merge_collected</span><span class="p">(</span><span class="n">collected</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">)</span>
    <span class="n">grouped</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">MergeElement</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">grouped</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">grouped</span>


<span class="k">def</span> <span class="nf">merge_coords</span><span class="p">(</span>
    <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">CoercibleMapping</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;minimal&quot;</span><span class="p">,</span>
    <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="n">priority_arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge coordinate variables.</span>

<span class="sd">    See merge_core below for argument descriptions. This works similarly to</span>
<span class="sd">    merge_core, except everything we don&#39;t worry about whether variables are</span>
<span class="sd">    coordinates or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_assert_compat_valid</span><span class="p">(</span><span class="n">compat</span><span class="p">)</span>
    <span class="n">coerced</span> <span class="o">=</span> <span class="n">coerce_pandas_values</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="n">aligned</span> <span class="o">=</span> <span class="n">deep_align</span><span class="p">(</span>
        <span class="n">coerced</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="n">collect_variables_and_indexes</span><span class="p">(</span><span class="n">aligned</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>
    <span class="n">prioritized</span> <span class="o">=</span> <span class="n">_get_priority_vars_and_indexes</span><span class="p">(</span><span class="n">aligned</span><span class="p">,</span> <span class="n">priority_arg</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">)</span>
    <span class="n">variables</span><span class="p">,</span> <span class="n">out_indexes</span> <span class="o">=</span> <span class="n">merge_collected</span><span class="p">(</span><span class="n">collected</span><span class="p">,</span> <span class="n">prioritized</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">out_indexes</span>


<span class="k">def</span> <span class="nf">merge_data_and_coords</span><span class="p">(</span>
    <span class="n">data_vars</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">,</span>
    <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_MergeResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Used in Dataset.__init__.&quot;&quot;&quot;</span>
    <span class="n">indexes</span><span class="p">,</span> <span class="n">coords</span> <span class="o">=</span> <span class="n">_create_indexes_from_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">data_vars</span><span class="p">)</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">coords</span><span class="p">]</span>
    <span class="n">explicit_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">merge_core</span><span class="p">(</span>
        <span class="n">objects</span><span class="p">,</span>
        <span class="n">compat</span><span class="p">,</span>
        <span class="n">join</span><span class="p">,</span>
        <span class="n">explicit_coords</span><span class="o">=</span><span class="n">explicit_coords</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="n">Indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">coords</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_create_indexes_from_coords</span><span class="p">(</span>
    <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">data_vars</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maybe create default indexes from a mapping of coordinates.</span>

<span class="sd">    Return those indexes and updated coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_variables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_vars</span><span class="p">)</span>

    <span class="n">indexes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">updated_coords</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># this is needed for backward compatibility: when a pandas multi-index</span>
    <span class="c1"># is given as data variable, it is promoted as index / level coordinates</span>
    <span class="c1"># TODO: depreciate this implicit behavior</span>
    <span class="n">index_vars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">index_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="n">name</span><span class="p">,):</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vars</span> <span class="o">=</span> <span class="n">create_default_index_implicit</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">all_variables</span><span class="p">)</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx_vars</span><span class="p">})</span>
            <span class="n">updated_coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>
            <span class="n">all_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">updated_coords</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">updated_coords</span>


<span class="k">def</span> <span class="nf">assert_valid_explicit_coords</span><span class="p">(</span>
    <span class="n">variables</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">explicit_coords</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate explicit coordinate names/dims.</span>

<span class="sd">    Raise a MergeError if an explicit coord shares a name with a dimension</span>
<span class="sd">    but is comprised of arbitrary dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">explicit_coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="n">variables</span><span class="p">[</span><span class="n">coord_name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="o">!=</span> <span class="p">(</span><span class="n">coord_name</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;coordinate </span><span class="si">{</span><span class="n">coord_name</span><span class="si">}</span><span class="s2"> shares a name with a dataset dimension, but is &quot;</span>
                <span class="s2">&quot;not a 1D variable along that dimension. This is disallowed &quot;</span>
                <span class="s2">&quot;by the xarray data model.&quot;</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">merge_attrs</span><span class="p">(</span><span class="n">variable_attrs</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine attributes from different variables according to combine_attrs&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">variable_attrs</span><span class="p">:</span>
        <span class="c1"># no attributes to merge</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">combine_attrs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">combine_attrs</span><span class="p">(</span><span class="n">variable_attrs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">combine_attrs</span> <span class="o">==</span> <span class="s2">&quot;drop&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="n">combine_attrs</span> <span class="o">==</span> <span class="s2">&quot;override&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variable_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">combine_attrs</span> <span class="o">==</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variable_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="n">variable_attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">compat_dict_union</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
                    <span class="s2">&quot;combine_attrs=&#39;no_conflicts&#39;, but some values are not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;the same. Merging </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">combine_attrs</span> <span class="o">==</span> <span class="s2">&quot;drop_conflicts&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dropped_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="n">variable_attrs</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">key</span><span class="p">:</span> <span class="n">value</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dropped_keys</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">value</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="ow">or</span> <span class="n">equivalent</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">dropped_keys</span> <span class="o">|=</span> <span class="p">{</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">combine_attrs</span> <span class="o">==</span> <span class="s2">&quot;identical&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variable_attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="n">variable_attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_equiv</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;combine_attrs=&#39;identical&#39;, but attrs differ. First is </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;, other is </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognised value for combine_attrs=</span><span class="si">{</span><span class="n">combine_attrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MergeResult</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span>
    <span class="n">coord_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Index</span><span class="p">]</span>
    <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">merge_core</span><span class="p">(</span>
    <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">CoercibleMapping</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">,</span>
    <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
    <span class="n">priority_arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">explicit_coords</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_MergeResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Core logic for merging labeled objects.</span>

<span class="sd">    This is not public API.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objects : list of mapping</span>
<span class="sd">        All values must be convertible to labeled arrays.</span>
<span class="sd">    compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, &quot;no_conflicts&quot;, &quot;override&quot;}, optional</span>
<span class="sd">        Compatibility checks to use when merging variables.</span>
<span class="sd">    join : {&quot;outer&quot;, &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;}, optional</span>
<span class="sd">        How to combine objects with different indexes.</span>
<span class="sd">    combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                     &quot;override&quot;} or callable, default: &quot;override&quot;</span>
<span class="sd">        How to combine attributes of objects</span>
<span class="sd">    priority_arg : int, optional</span>
<span class="sd">        Optional argument in `objects` that takes precedence over the others.</span>
<span class="sd">    explicit_coords : set, optional</span>
<span class="sd">        An explicit list of variables from `objects` that are coordinates.</span>
<span class="sd">    indexes : dict, optional</span>
<span class="sd">        Dictionary with values given by xarray.Index objects or anything that</span>
<span class="sd">        may be cast to pandas.Index objects.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Value to use for newly missing values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variables : dict</span>
<span class="sd">        Dictionary of Variable objects.</span>
<span class="sd">    coord_names : set</span>
<span class="sd">        Set of coordinate names.</span>
<span class="sd">    dims : dict</span>
<span class="sd">        Dictionary mapping from dimension names to sizes.</span>
<span class="sd">    attrs : dict</span>
<span class="sd">        Dictionary of attributes</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    MergeError if the merge cannot be done successfully.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="n">_assert_compat_valid</span><span class="p">(</span><span class="n">compat</span><span class="p">)</span>

    <span class="n">coerced</span> <span class="o">=</span> <span class="n">coerce_pandas_values</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="n">aligned</span> <span class="o">=</span> <span class="n">deep_align</span><span class="p">(</span>
        <span class="n">coerced</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
    <span class="p">)</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="n">collect_variables_and_indexes</span><span class="p">(</span><span class="n">aligned</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">)</span>
    <span class="n">prioritized</span> <span class="o">=</span> <span class="n">_get_priority_vars_and_indexes</span><span class="p">(</span><span class="n">aligned</span><span class="p">,</span> <span class="n">priority_arg</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">)</span>
    <span class="n">variables</span><span class="p">,</span> <span class="n">out_indexes</span> <span class="o">=</span> <span class="n">merge_collected</span><span class="p">(</span>
        <span class="n">collected</span><span class="p">,</span> <span class="n">prioritized</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span>
    <span class="p">)</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="n">calculate_dimensions</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="n">coord_names</span><span class="p">,</span> <span class="n">noncoord_names</span> <span class="o">=</span> <span class="n">determine_coords</span><span class="p">(</span><span class="n">coerced</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">explicit_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">assert_valid_explicit_coords</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">explicit_coords</span><span class="p">)</span>
        <span class="n">coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">explicit_coords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">coord_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">ambiguous_coords</span> <span class="o">=</span> <span class="n">coord_names</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">noncoord_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ambiguous_coords</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MergeError</span><span class="p">(</span>
            <span class="s2">&quot;unable to determine if these variables should be &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;coordinates or not in the merged result: </span><span class="si">{</span><span class="n">ambiguous_coords</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="n">merge_attrs</span><span class="p">(</span>
        <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">attrs</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">coerced</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">))],</span>
        <span class="n">combine_attrs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_MergeResult</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">out_indexes</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>


<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../../../api/xugrid.merge.html#xugrid.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
    <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">CoercibleMapping</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span> <span class="o">=</span> <span class="s2">&quot;no_conflicts&quot;</span><span class="p">,</span>
    <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
    <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span> <span class="o">=</span> <span class="s2">&quot;override&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge any number of xarray objects into a single Dataset as variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objects : iterable of Dataset or iterable of DataArray or iterable of dict-like</span>
<span class="sd">        Merge together all variables from these objects. If any of them are</span>
<span class="sd">        DataArray objects, they must have a name.</span>
<span class="sd">    compat : {&quot;identical&quot;, &quot;equals&quot;, &quot;broadcast_equals&quot;, &quot;no_conflicts&quot;, \</span>
<span class="sd">              &quot;override&quot;, &quot;minimal&quot;}, default: &quot;no_conflicts&quot;</span>
<span class="sd">        String indicating how to compare variables of the same name for</span>
<span class="sd">        potential conflicts:</span>

<span class="sd">        - &quot;identical&quot;: all values, dimensions and attributes must be the</span>
<span class="sd">          same.</span>
<span class="sd">        - &quot;equals&quot;: all values and dimensions must be the same.</span>
<span class="sd">        - &quot;broadcast_equals&quot;: all values must be equal when variables are</span>
<span class="sd">          broadcast against each other to ensure common dimensions.</span>
<span class="sd">        - &quot;no_conflicts&quot;: only values which are not null in both datasets</span>
<span class="sd">          must be equal. The returned dataset then contains the combination</span>
<span class="sd">          of all non-null values.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and pick variable from first dataset</span>
<span class="sd">        - &quot;minimal&quot;: drop conflicting coordinates</span>

<span class="sd">    join : {&quot;outer&quot;, &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;exact&quot;, &quot;override&quot;}, default: &quot;outer&quot;</span>
<span class="sd">        String indicating how to combine differing indexes in objects.</span>

<span class="sd">        - &quot;outer&quot;: use the union of object indexes</span>
<span class="sd">        - &quot;inner&quot;: use the intersection of object indexes</span>
<span class="sd">        - &quot;left&quot;: use indexes from the first object with each dimension</span>
<span class="sd">        - &quot;right&quot;: use indexes from the last object with each dimension</span>
<span class="sd">        - &quot;exact&quot;: instead of aligning, raise `ValueError` when indexes to be</span>
<span class="sd">          aligned are not equal</span>
<span class="sd">        - &quot;override&quot;: if indexes are of same size, rewrite indexes to be</span>
<span class="sd">          those of the first object with that dimension. Indexes for the same</span>
<span class="sd">          dimension must have the same size in all objects.</span>

<span class="sd">    fill_value : scalar or dict-like, optional</span>
<span class="sd">        Value to use for newly missing values. If a dict-like, maps</span>
<span class="sd">        variable names to fill values. Use a data array&#39;s name to</span>
<span class="sd">        refer to its values.</span>
<span class="sd">    combine_attrs : {&quot;drop&quot;, &quot;identical&quot;, &quot;no_conflicts&quot;, &quot;drop_conflicts&quot;, \</span>
<span class="sd">                     &quot;override&quot;} or callable, default: &quot;override&quot;</span>
<span class="sd">        A callable or a string indicating how to combine attrs of the objects being</span>
<span class="sd">        merged:</span>

<span class="sd">        - &quot;drop&quot;: empty attrs on returned Dataset.</span>
<span class="sd">        - &quot;identical&quot;: all attrs must be the same on every object.</span>
<span class="sd">        - &quot;no_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name must also have the same value.</span>
<span class="sd">        - &quot;drop_conflicts&quot;: attrs from all objects are combined, any that have</span>
<span class="sd">          the same name but different values are dropped.</span>
<span class="sd">        - &quot;override&quot;: skip comparing and copy attrs from the first dataset to</span>
<span class="sd">          the result.</span>

<span class="sd">        If a callable, it must expect a sequence of ``attrs`` dicts and a context object</span>
<span class="sd">        as its only parameters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dataset</span>
<span class="sd">        Dataset with combined variables from each object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = xr.DataArray(</span>
<span class="sd">    ...     [[1.0, 2.0], [3.0, 5.0]],</span>
<span class="sd">    ...     dims=(&quot;lat&quot;, &quot;lon&quot;),</span>
<span class="sd">    ...     coords={&quot;lat&quot;: [35.0, 40.0], &quot;lon&quot;: [100.0, 120.0]},</span>
<span class="sd">    ...     name=&quot;var1&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; y = xr.DataArray(</span>
<span class="sd">    ...     [[5.0, 6.0], [7.0, 8.0]],</span>
<span class="sd">    ...     dims=(&quot;lat&quot;, &quot;lon&quot;),</span>
<span class="sd">    ...     coords={&quot;lat&quot;: [35.0, 42.0], &quot;lon&quot;: [100.0, 150.0]},</span>
<span class="sd">    ...     name=&quot;var2&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; z = xr.DataArray(</span>
<span class="sd">    ...     [[0.0, 3.0], [4.0, 9.0]],</span>
<span class="sd">    ...     dims=(&quot;time&quot;, &quot;lon&quot;),</span>
<span class="sd">    ...     coords={&quot;time&quot;: [30.0, 60.0], &quot;lon&quot;: [100.0, 150.0]},</span>
<span class="sd">    ...     name=&quot;var3&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    &lt;xarray.DataArray &#39;var1&#39; (lat: 2, lon: 2)&gt;</span>
<span class="sd">    array([[1., 2.],</span>
<span class="sd">           [3., 5.]])</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0</span>

<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    &lt;xarray.DataArray &#39;var2&#39; (lat: 2, lon: 2)&gt;</span>
<span class="sd">    array([[5., 6.],</span>
<span class="sd">           [7., 8.]])</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 150.0</span>

<span class="sd">    &gt;&gt;&gt; z</span>
<span class="sd">    &lt;xarray.DataArray &#39;var3&#39; (time: 2, lon: 2)&gt;</span>
<span class="sd">    array([[0., 3.],</span>
<span class="sd">           [4., 9.]])</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">      * lon      (lon) float64 100.0 150.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z])</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 3, lon: 3, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0 150.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan</span>
<span class="sd">        var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], compat=&quot;identical&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 3, lon: 3, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0 150.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan</span>
<span class="sd">        var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], compat=&quot;equals&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 3, lon: 3, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0 150.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan</span>
<span class="sd">        var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], compat=&quot;equals&quot;, fill_value=-999.0)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 3, lon: 3, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0 150.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 -999.0 3.0 ... -999.0 -999.0 -999.0</span>
<span class="sd">        var2     (lat, lon) float64 5.0 -999.0 6.0 -999.0 ... -999.0 7.0 -999.0 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 -999.0 3.0 4.0 -999.0 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], join=&quot;override&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 2, lon: 2, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 3.0 5.0</span>
<span class="sd">        var2     (lat, lon) float64 5.0 6.0 7.0 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 3.0 4.0 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], join=&quot;inner&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 1, lon: 1, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0</span>
<span class="sd">      * lon      (lon) float64 100.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0</span>
<span class="sd">        var2     (lat, lon) float64 5.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 4.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], compat=&quot;identical&quot;, join=&quot;inner&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 1, lon: 1, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0</span>
<span class="sd">      * lon      (lon) float64 100.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0</span>
<span class="sd">        var2     (lat, lon) float64 5.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 4.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], compat=&quot;broadcast_equals&quot;, join=&quot;outer&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt;</span>
<span class="sd">    Dimensions:  (lat: 3, lon: 3, time: 2)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">      * lat      (lat) float64 35.0 40.0 42.0</span>
<span class="sd">      * lon      (lon) float64 100.0 120.0 150.0</span>
<span class="sd">      * time     (time) float64 30.0 60.0</span>
<span class="sd">    Data variables:</span>
<span class="sd">        var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan</span>
<span class="sd">        var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0</span>
<span class="sd">        var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0</span>

<span class="sd">    &gt;&gt;&gt; xr.merge([x, y, z], join=&quot;exact&quot;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: cannot align objects with join=&#39;exact&#39; where ...</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    xarray.MergeError</span>
<span class="sd">        If any variables with the same name have conflicting values.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    concat</span>
<span class="sd">    combine_nested</span>
<span class="sd">    combine_by_coords</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="n">dict_like_objects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;objects must be an iterable containing only &quot;</span>
                <span class="s2">&quot;Dataset(s), DataArray(s), and dictionaries.&quot;</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">promote_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">obj</span>
        <span class="n">dict_like_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="n">merge_result</span> <span class="o">=</span> <span class="n">merge_core</span><span class="p">(</span>
        <span class="n">dict_like_objects</span><span class="p">,</span>
        <span class="n">compat</span><span class="p">,</span>
        <span class="n">join</span><span class="p">,</span>
        <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">_construct_direct</span><span class="p">(</span><span class="o">**</span><span class="n">merge_result</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">dataset_merge_method</span><span class="p">(</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span><span class="p">,</span>
    <span class="n">overwrite_vars</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">compat</span><span class="p">:</span> <span class="n">CompatOptions</span><span class="p">,</span>
    <span class="n">join</span><span class="p">:</span> <span class="n">JoinOptions</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">combine_attrs</span><span class="p">:</span> <span class="n">CombineAttrsOptions</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_MergeResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Guts of the Dataset.merge method.&quot;&quot;&quot;</span>
    <span class="c1"># we are locked into supporting overwrite_vars for the Dataset.merge</span>
    <span class="c1"># method due for backwards compatibility</span>
    <span class="c1"># TODO: consider deprecating it?</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overwrite_vars</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overwrite_vars</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">overwrite_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">overwrite_vars</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overwrite_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">overwrite_vars</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_vars</span><span class="p">:</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
        <span class="n">priority_arg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">overwrite_vars</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
        <span class="n">priority_arg</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_overwrite</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">other_no_overwrite</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">CoercibleValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">overwrite_vars</span><span class="p">:</span>
                <span class="n">other_overwrite</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_no_overwrite</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="p">,</span> <span class="n">other_no_overwrite</span><span class="p">,</span> <span class="n">other_overwrite</span><span class="p">]</span>
        <span class="n">priority_arg</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">merge_core</span><span class="p">(</span>
        <span class="n">objs</span><span class="p">,</span>
        <span class="n">compat</span><span class="p">,</span>
        <span class="n">join</span><span class="p">,</span>
        <span class="n">priority_arg</span><span class="o">=</span><span class="n">priority_arg</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="n">combine_attrs</span><span class="o">=</span><span class="n">combine_attrs</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dataset_update_method</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">CoercibleMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_MergeResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Guts of the Dataset.update method.</span>

<span class="sd">    This drops a duplicated coordinates from `other` if `other` is not an</span>
<span class="sd">    `xarray.Dataset`, e.g., if it&#39;s a dict with DataArray values (GH2068,</span>
<span class="sd">    GH2180).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
    <span class="kn">from</span> <span class="nn">xarray.core.dataset</span> <span class="kn">import</span> <span class="n">Dataset</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="c1"># drop conflicting coordinates</span>
                <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">c</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">coords</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">coords</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">coord_names</span><span class="p">:</span>
                    <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merge_core</span><span class="p">(</span>
        <span class="p">[</span><span class="n">dataset</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span>
        <span class="n">priority_arg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">xindexes</span><span class="p">,</span>
        <span class="n">combine_attrs</span><span class="o">=</span><span class="s2">&quot;override&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
       Copyright Deltares.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>